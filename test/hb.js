// LWE-based idscheme

var IDscheme = require('../idscheme.js');
//-----------------------------------Global variables-----------------------------------

//s1 and s2 are shared keys
var glob_s1,
	glob_s2;

var glob_q,
	glob_m;
var glob_ka,
	glob_to;
var glob_a, // generated by Verifier
	glob_b; // generated by Prover

//--------------------------------------------------------------------------------------

//commitment function
function com(){
	var param;
	param = (arguments[0]+arguments[1]);
	return IDscheme.sha256(param);
}


function keyGeneration(m, ka, to, q) {
	// shared keys s1 and s2  
	var s1 = [];
	var s2 = [];
	glob_q = q;
	glob_ka = ka;
	glob_to = to
	glob_m = m;

	//s1
	for (var i = 0; i < ka; i++) { 
		s1[i] = IDscheme.nextInt(glob_q);
	}
	
	//s2
	for (var i = 0; i < to; i++) { 
		s2[i] = IDscheme.nextInt(glob_q);
	}

	//shared keys
	glob_s1 = s1;
	glob_s2 = s2;
}

// Prover: p1()
function p1(){ 
	var b = [];

	//blind factor b
	for (var i = 0; i < glob_ka; i++) { 
		b[i] = IDscheme.nextInt(glob_q);
	}

	glob_b = b;
	
}

// Verifier: v1()
function v1(){
	var a = [];

	//random challenge vector aa
	for (var i = 0; i < glob_to; i++) { 
		a[i] = IDscheme.nextInt(glob_q);
	}

	glob_a = a;
}

// Prover: p2()
function p2(){
	var z = [];
	var v = [];

	//TODO: Generate from Bernoulli distribution!
	//vector v <- {0,1}^m according to the Bernoulli distribution(depending on X:error_distribution)
	for (var i = 0; i < glob_m; i++) { 
		v[i] = IDscheme.nextInt(2);
	}

	var part1 = IDscheme.addVectors(glob_s1, glob_b);
	var part2 = IDscheme.addVectors(glob_s2, glob_a);

	//Padding (otherwise, vector's length doesnt match)
	/*for (var i = glob_to; i < glob_ka; i++) { 
		part2[i] = 0;
	}*/
	part2 = IDscheme.padding(part2,glob_ka);

	//Padding
	/*for (var i = glob_m; i < glob_ka; i++) { 
		v[i] = 0;
	}*/

	v = IDscheme.padding(v,glob_ka);

	var part3 = IDscheme.addVectors(part1, part2); 
	//print("Part3:");
	//print(part3);

	z = IDscheme.addVectors(part3, v);
	//print("Z:");
	//print(z);
	
	var z_modp = IDscheme.modVector(z,glob_q);
	//print("Z modp:");
	//print(z_modp);

	return z;
}

// Verifier: v2()
function v2(z){
	var comp1, comp2, comp3; // computations

	var part1 = IDscheme.addVectors(glob_s1, glob_b);
	var part2 = IDscheme.addVectors(glob_s2, glob_a);
	
	comp1 = IDscheme.vectorSubtract(z, part1);
	/*print("Z - <s1,b>:");
	print(comp1);*/

	//Padding (otherwise, vector's length doesnt match)
	for (var i = glob_to; i < glob_ka; i++) { 
		part2[i] = 0;
	}

	comp2 = IDscheme.vectorSubtract(comp1, part2);
	//print("Z - <s1,b> - <s2,a>:");
	//print(comp2);

	function mutlak_deger(x) {
		var y = [];
		for(var i=0; i<x.length;i++){
			if(x[i]<0){
				x[i]=x[i]*(-1);
			}
			y.push(x[i]);
		}
		return y;
	}

	var negatifsiz = mutlak_deger(comp2);
	/*print("Negatifsiz:");
	print(negatifsiz);
	*/
	var sonuc_modp = IDscheme.modVector(comp2,glob_q);
	//print("Z - <s1,b> - <s2,a> modp:");
	//print(sonuc_modp);

	for(var i=0; i<glob_ka;i++){
		if(sonuc_modp[i]>tolerance){
			print("Failed!");
			return;
		}
	}
	print("Success!");
}

//===============================================================================
//------------------------------------------- start --------------------------------------------------
var nu = 0.125,
	q = 1024, 
	m = 256,
	ka = 512,
	to = 80,
	tolerance = 1024;


function testidscheme() {
	print("HB+ LWE-based ID Scheme:");
	print("Parameters Set:");
	print("nu = " + nu);
	print("m = " + m);
	print("q = " + q);
	print("ka = " + ka);
	print("to = " + to);
	print("Tolerance = " + tolerance);
	keyGeneration(m, ka, to, q);

	print("Prover: computes a blinding factor b.");
	p1();
	print("Verifier: sends a challenge a. ");
	v1();
	print("Prover: computes the answer z and sends it to the Verifier.");
	print("Verifier: checks for correctness depending on Tolerance value and accepts in case of success. ");
	
	var response = p2();
	v2(response);

}
//***********************************************************
function print(message) {
	//WScript.Echo(message);
	console.log(message);
}
testidscheme();
